package server;// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.*;import java.util.Arrays;import java.util.Observable;import java.util.Observer;import com.lloseng.ocsf.server.*;import common.ChatIF;/** * This class overrides some of the methods in the abstract superclass in order * to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements Observer {	// Instance variables **********************************************	/**	 * The interface type variable. It allows the implementation of the display	 * method in the server.	 */	ChatIF serverUI;	boolean serverclosed;	ObservableOriginatorServer serverCommunication;	// Constructors ****************************************************	/**	 * Constructs an instance of the echo server.	 *	 * @param port The port number to connect on.	 */	public EchoServer(int port, ChatIF serverUI) {		serverCommunication = new ObservableOriginatorServer(port);		this.serverUI = serverUI;		serverCommunication.addObserver(this);	}	// Instance methods ************************************************	/**	 * This method handles any messages received from the client.	 *	 * @param msg    The message received from the client.	 * @param client The connection from which the message originated.	 */	public void handleMessageFromClient(Object msg, ConnectionToClient client) {		if (isLogged(client) || msg.toString().startsWith("#login")) {			if (isACommand(msg.toString())) {				handleCommandFromClient(msg.toString().substring(1), client);			} else {				serverUI.display("Message received: " + msg + " from " + client.getInfo("id"));				serverCommunication.sendToAllClients(client.getInfo("id") + ": " + msg);			}		} else {			try {				client.sendToClient("Server MSG> Give your username while connecting");				client.sendToClient("#logoff");				client.close();			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}		}	}	public boolean isServerclosed() {		return serverclosed;	}	public void setServerclosed(boolean severclosed) {		this.serverclosed = severclosed;	}	/**	 * This method overrides the one in the superclass. Called when the server	 * starts listening for connections.	 */	protected void serverStarted() {		serverUI.display("Server listening for connections on port " + serverCommunication.getPort());	}	/**	 * This method overrides the one in the superclass. Called when the server stops	 * listening for connections.	 */	protected void serverStopped() {		serverUI.display("Server has stopped listening for connections.");	}	protected void clientConnected(ConnectionToClient client) {		serverUI.display("Client connected : " + client.getInetAddress());	}	synchronized protected void clientDisconnected(ConnectionToClient client) {		serverUI.display("Client disconnected : " + client.getInfo("id"));		serverCommunication.sendToAllClients(client.getInfo("id") + " disconnected");	}	public void handleMessageFromServerUI(String message) {		if (isACommand(message)) {			handleCommand(message.substring(1));		} else {			serverCommunication.sendToAllClients("Server MSG> " + message);		}	}	public void handleCommand(String cmd) {		String[] s = cmd.split(" ");		if (s[0].equals("quit")) {			quit();		} else if (s[0].equals("stop")) {			serverCommunication.stopListening();		} else if (s[0].equals("close")) {			closeServer();		} else if (s[0].equals("setport")) {			if (!isServerclosed()) {				this.serverUI.display("can't change port, server running");			} else {				serverCommunication.setPort(Integer.parseInt(s[1]));			}		} else if (s[0].equals("start")) {			if (!isServerclosed()) {				this.serverUI.display("server already running");			} else {				try {					serverCommunication.listen();				} catch (IOException e) {				}			}		} else if (s[0].equals("getport")) {			this.serverUI.display("port : " + serverCommunication.getPort());		}	}	public void closeServer() {		try {			serverCommunication.close();		} catch (IOException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}		setServerclosed(true);	}	public void quit() {		closeServer();		System.exit(0);	}	/**	 * Handle the commands received from the client	 * 	 * @param cmd    The command string without "#"	 * @param client The client which has sent the command	 */	public void handleCommandFromClient(String cmd, ConnectionToClient client) {		String[] s = cmd.split(" ");		if (s[0].equals("logoff")) {			try {				client.close();			} catch (IOException e) {			}		} else if (s[0].equals("login")) {			if (s.length < 2) {				try {					client.sendToClient("Server MSG> Give your username while connecting");					client.sendToClient("#logoff");					client.close();				} catch (IOException e) {					e.printStackTrace();				}			}			if (!isLogged(client)) {				client.setInfo("id", s[1]);				serverCommunication.sendToAllClients(client.getInfo("id") + " connected");			} else {				try {					client.sendToClient("you are already logged");				} catch (IOException e) {				}			}		}	}	public boolean isLogged(ConnectionToClient client) {		return client.getInfo("id") != null;	}	/**	 * @param msg	 * @return true if the msg is a command (starting with "#")	 */	public boolean isACommand(String msg) {		return msg.charAt(0) == '#';	}	protected void listeningException(String msg) {		serverUI.display("Listening exception : " + msg);	}	synchronized protected void clientException(ConnectionToClient client, String msg) {		serverUI.display("Client exception : " + msg);	}	@Override	public void update(Observable arg0, Object arg1) {		OriginatorMessage orgmess = (OriginatorMessage) arg1;		ConnectionToClient client = orgmess.getOriginator();		Object msg = orgmess.getMessage();		String message = msg.toString();		if (message.startsWith(serverCommunication.CLIENT_CONNECTED)) {			clientConnected(client);		} else if (message.startsWith(serverCommunication.CLIENT_DISCONNECTED)) {			clientDisconnected(client);		} else if (message.startsWith(serverCommunication.SERVER_STARTED)) {			serverStarted();		} else if (message.startsWith(serverCommunication.SERVER_STOPPED)) {			serverStopped();		} else if (message.startsWith(serverCommunication.SERVER_CLOSED)) {			setServerclosed(true);		} else if (message.startsWith(serverCommunication.CLIENT_EXCEPTION)) {			clientException(client, message);		} else if (message.startsWith(serverCommunication.LISTENING_EXCEPTION)) {			listeningException(message);		} else {			handleMessageFromClient(message, client);		}	}	public void listen() throws IOException {		serverCommunication.listen();	}}//End of EchoServer class